<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wood Block Puzzle Challenge (2025) - Play Free Online | GameVerse</title>
    <meta name="description" content="Play the engaging Wood Block Puzzle game online for free at GameVerse (2025 Edition)! Test your strategy and spatial skills. Learn how to play, get tips for high scores, and enjoy this classic brain teaser.">
    <meta name="keywords" content="wood block puzzle, puzzle game online, free block puzzle, brain teaser game, strategy puzzle, GameVerse, Kanhaiya Mishra, 2025 puzzle games, play wooden puzzle">
    <meta name="author" content="Kanhaiya Mishra - GameVerse">
    <link rel="canonical" href="https://online-games-indol.vercel.app/wooden_puzzle_page.html"> <!-- UPDATE URL -->

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://online-games-indol.vercel.app/wooden_puzzle_page.html"> <!-- UPDATE URL -->
    <meta property="og:title" content="Wood Block Puzzle Challenge (2025) - Play Free Online | GameVerse">
    <meta property="og:description" content="Addictive Wood Block Puzzle game on GameVerse! Fit blocks, clear lines, and aim for a high score. Fun for all puzzle lovers.">
    <meta property="og:image" content="https://online-games-indol.vercel.app/images/wooden-puzzle-social-2025.png"> <!-- CREATE/UPDATE IMAGE -->

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://online-games-indol.vercel.app/wooden_puzzle_page.html"> <!-- UPDATE URL -->
    <meta property="twitter:title" content="Wood Block Puzzle Challenge (2025) - Play Free Online | GameVerse">
    <meta property="twitter:description" content="Play the captivating Wood Block Puzzle on GameVerse. Free, fun, and challenging for all ages.">
    <meta property="twitter:image" content="https://online-games-indol.vercel.app/images/wooden-puzzle-social-2025.png"> <!-- CREATE/UPDATE IMAGE -->

    <!-- Favicon (Ensure these files are in your root or update path) -->
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#00adb5"> 
    <meta name="msapplication-TileColor" content="#222831"> 
    <meta name="theme-color" content="#222831"> 

    <!-- Google AdSense Script -->
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8067952496194704"
         crossorigin="anonymous"></script>

    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600&family=Roboto+Slab:wght@400;700&display=swap" rel="stylesheet">

    <style>
        :root {
            --gv-top-nav-bg: #1a1a1a; /* Consistent with other pages' nav */
            --gv-top-nav-text: #eeeeee;
            --gv-top-nav-link-hover-bg: #2c2c2c;
            --gv-primary-accent-footer: #00adb5; /* Teal from index page footer */

            /* Game Specific Theme (Browns for Wooden Puzzle) */
            --game-primary-bg: #654321; /* Main page background */
            --game-container-bg: #8B4513; /* Game box background */
            --game-text-light: #FFF0E1; /* Light text on dark wood */
            --game-accent-dark-wood: #603813; /* Darker wood accents */
            --game-accent-medium-wood: #A0522D; /* Medium wood accents */
            --game-accent-highlight: #FFD700; /* Gold for highlights */
        }
        body {
            font-family: 'Poppins', sans-serif;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: var(--game-primary-bg);
            touch-action: manipulation; 
            overflow-x: hidden;
            padding-top: 70px; /* Space for fixed header */
        }

        .top-nav-bar {
            position: fixed; top: 0; left: 0; width: 100%;
            background-color: var(--gv-top-nav-bg); 
            color: var(--gv-top-nav-text); padding: 12px 25px;
            display: flex; justify-content: space-between; align-items: center;
            box-shadow: 0 3px 8px rgba(0,0,0,0.3); z-index: 1010;
            border-bottom: 2px solid var(--gv-primary-accent-footer); 
            min-height: 50px;
        }
        .top-nav-bar .logo a { color: var(--gv-top-nav-text); text-decoration: none; font-size: 1.4em; font-weight: 700; font-family: 'Roboto Slab', serif;}
        .top-nav-bar .nav-links { display: flex; align-items: center; flex-wrap: wrap;}
        .top-nav-bar .nav-links a { color: var(--gv-top-nav-text); text-decoration: none; margin-left: 18px; font-size: 0.95em; padding: 6px 10px; border-radius: 5px; transition: background-color 0.2s ease, color 0.2s ease; }
        .top-nav-bar .nav-links a:hover, .top-nav-bar .nav-links a.active { 
            background-color: var(--gv-top-nav-link-hover-bg); 
            color: var(--gv-primary-accent-footer); 
        }

        .site-footer {
            text-align: center; padding: 25px 0; margin-top: auto;
            width:100%; background-color: var(--gv-top-nav-bg);
            color: var(--gv-top-nav-text); opacity: 0.95; font-size: 0.9em;
            border-top: 3px solid var(--gv-primary-accent-footer);
        }
        .site-footer a { color: var(--gv-primary-accent-footer); text-decoration: none; font-weight: 500;}
        .site-footer a:hover { text-decoration: underline; color: #fff;}
        .footer-links-group { margin-top: 8px; margin-bottom: 15px; } 
        .footer-links-group a { margin: 0 8px; }
        .footer-social-links { 
            margin-top: 15px; padding-top: 15px; border-top: 1px solid #444; 
        }
        .footer-social-links p {
             margin-bottom: 10px; font-size: 1em; font-weight: 500; color: var(--gv-top-nav-text);
        }
        .footer-social-links a { display: inline-block; margin: 0 10px; transition: transform 0.2s ease; }
        .footer-social-links img { width: 32px; height: 32px; vertical-align: middle; }
        .footer-social-links a:hover { transform: scale(1.15); text-decoration: none; }


        body.dragging-active { cursor: grabbing; }
        .game-container {
            background-color: var(--game-container-bg); padding: 20px; border-radius: 10px;
            box-shadow: 0 0 20px rgba(0,0,0,0.5), inset 0 0 15px rgba(50,20,0,0.7);
            text-align: center; max-width: 90vw; width: 400px; user-select: none;
            -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none;
            position: relative; margin-top: 20px; margin-bottom: 20px; /* Added top margin */
        }
        .screen { display: none; }
        .screen.active { display: block; }
        #score-area {
            background-color: var(--game-accent-medium-wood); color: var(--game-text-light); font-size: 24px; font-weight: bold;
            padding: 10px 20px; border-radius: 8px; box-shadow: inset 0 2px 4px rgba(0,0,0,0.3);
            border: 2px solid #6B4226; flex-grow: 1; text-align: center;
        }
        #game-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
        #back-to-difficulty-btn {
            background-color: var(--game-accent-medium-wood); color: var(--game-text-light); border: 1px solid #6B4226;
            padding: 5px 10px; font-size: 14px; border-radius: 5px; cursor: pointer;
            box-shadow: 0 2px #6B4226; margin-right: 10px;
        }
        #back-to-difficulty-btn:hover { background-color: #804020; }
        #back-to-difficulty-btn:active { transform: translateY(1px); box-shadow: 0 1px #6B4226; }
        #game-board {
            display: grid; grid-template-columns: repeat(10, 1fr); grid-template-rows: repeat(10, 1fr);
            width: 100%; aspect-ratio: 1 / 1; background-color: var(--game-accent-medium-wood);
            border: 3px solid var(--game-accent-dark-wood); box-shadow: inset 0 0 10px rgba(0,0,0,0.4);
            margin-bottom: 20px; position: relative;
        }
        .grid-cell {
            background-color: #DEB887; border: 1px solid #B8860B;
            box-shadow: inset 1px 1px 2px rgba(0,0,0,0.1), inset -1px -1px 2px rgba(255,255,255,0.2);
            transition: background-color 0.1s;
        }
        .grid-cell.filled {
            background-color: #CD853F; border: 1px solid #8B4513;
            box-shadow: inset 2px 2px 5px rgba(0,0,0,0.3), 0 0 3px rgba(255,222,173,0.5);
        }
        .grid-cell.preview { background-color: rgba(255, 255, 255, 0.5) !important; outline: 1px dashed #333; }
        
        @keyframes destroyEffect {
            0% { transform: scale(1); opacity: 1; background-color: #FFFACD; }
            50% { transform: scale(1.1); opacity: 0.8; background-color: var(--game-accent-highlight); }
            100% { transform: scale(0.1); opacity: 0; background-color: #CD853F; }
        }
        .grid-cell.line-clearing { animation: destroyEffect 0.4s ease-out forwards; }

        .combo-popup {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.75); color: white; padding: 15px 30px;
            border-radius: 10px; font-size: 28px; font-weight: bold; z-index: 1001;
            opacity: 0; transition: opacity 0.3s ease-out, transform 0.3s ease-out;
            pointer-events: none; text-shadow: 1px 1px 2px #000;
        }
        .combo-popup.show { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
        .combo-popup.hide { opacity: 0; transform: translate(-50%, -50%) scale(0.9); }
        
        #game-over-message {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -60%);
            background-color: rgba(139, 69, 19, 0.95); color: var(--game-text-light); padding: 25px;
            border-radius: 15px; border: 3px solid var(--game-accent-dark-wood); box-shadow: 0 5px 15px rgba(0,0,0,0.4);
            z-index: 1002; text-align: center; width: 80%; max-width: 320px;
        }
        #game-over-message h3 { margin-top: 0; margin-bottom: 15px; font-size: 24px; color: var(--game-accent-highlight); font-family: 'Roboto Slab', serif;}
        #game-over-message p { margin: 8px 0; font-size: 18px; }
        
        #piece-container {
            display: flex; justify-content: space-around; align-items: flex-start;
            min-height: 80px; padding: 10px; background-color: var(--game-accent-medium-wood);
            border-radius: 8px; box-shadow: inset 0 0 8px rgba(0,0,0,0.3);
        }
        .piece-slot { width: 30%; display: flex; justify-content: center; align-items: center; min-height: 60px; }
        .piece { display: grid; cursor: grab; border: 1px solid transparent; touch-action: none; }
        .piece.is-being-dragged { opacity: 0.3; cursor: grabbing; }
        .piece.hint-piece { opacity: 0.6; cursor: default !important; }
        .piece-cell {
            width: 18px; height: 18px; background-color: #CD853F;
            border: 1px solid #8B4513; box-shadow: inset 1px 1px 3px rgba(0,0,0,0.2);
        }
        .piece-cell.empty { background-color: transparent; border: none; box-shadow: none; }
        .piece-clone {
            position: absolute; z-index: 1000; opacity: 0.75;
            pointer-events: none; transform-origin: top left;
        }
        button, .difficulty-btn, #start-game-btn, #back-to-difficulty-btn, #restart-game-over-btn  { /* More specific selectors */
            background-color: #D2691E; color: white; border: 2px solid #8B4513;
            padding: 12px 25px; font-size: 18px; border-radius: 8px; cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
            box-shadow: 0 4px #8B4513; margin: 10px 5px;
            font-family: 'Poppins', sans-serif; /* Ensure consistent font */
        }
        button:hover, .difficulty-btn:hover, #start-game-btn:hover, #back-to-difficulty-btn:hover, #restart-game-over-btn:hover { background-color: #B85C1A; }
        button:active, .difficulty-btn:active, #start-game-btn:active, #back-to-difficulty-btn:active, #restart-game-over-btn:active { transform: translateY(2px); box-shadow: 0 2px #8B4513; }
        
        #back-to-difficulty-btn { font-size: 14px; padding: 8px 15px; } /* Smaller back button */

        h1, .game-container h2 { color: var(--game-text-light); font-family: 'Roboto Slab', serif;} /* Game container specific h2 */
        
        .music-controls { margin-top: 20px; padding-top: 15px; border-top: 1px solid #6B4226; }
        .music-controls h3 { margin-bottom: 10px; font-size: 18px; color: var(--game-text-light); font-family: 'Roboto Slab', serif;}
        .volume-control-container { display: flex; align-items: center; justify-content: center; margin-top: 5px; }
        #volume-slider { width: 180px; cursor: pointer; }

        .game-info-section {
            background-color: var(--game-container-bg); 
            color: var(--game-text-light);
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0,0,0,0.3), inset 0 0 10px rgba(50,20,0,0.5);
            margin-top: 30px;
            margin-bottom: 30px;
            max-width: 90vw;
            width: 700px; 
            text-align: left;
            line-height: 1.7;
        }
        .game-info-section h2 {
            font-family: 'Roboto Slab', serif;
            color: var(--game-accent-highlight); 
            border-bottom: 2px solid var(--game-accent-medium-wood);
            padding-bottom: 10px;
            margin-top: 0;
            margin-bottom: 20px;
            font-size: 2em;
        }
        .game-info-section h3 {
            font-family: 'Roboto Slab', serif;
            color: var(--game-accent-highlight);
            margin-top: 25px;
            margin-bottom: 12px;
            font-size: 1.6em;
        }
        .game-info-section p, .game-info-section ol, .game-info-section ul {
            font-size: 1.05em;
            margin-bottom: 15px;
        }
        .game-info-section ol, .game-info-section ul {
            padding-left: 30px;
        }
        .game-info-section ul li { list-style: disc; margin-bottom: 8px; padding-left: 5px;}
        .game-info-section ol li { list-style: decimal; margin-bottom: 8px;}
        .game-info-section strong { font-weight: 600; color: var(--game-accent-highlight);}

         @media (max-width: 768px) {
            .game-info-section { width: 90vw; padding: 20px;}
            .game-info-section h2 { font-size: 1.8em; }
            .game-info-section h3 { font-size: 1.4em; }
        }
         @media (max-width: 600px) {
            body { padding-top: 120px; } 
            .top-nav-bar { flex-direction: column; align-items: flex-start; gap: 8px; height: auto; padding-bottom: 10px;}
            .top-nav-bar .nav-links { width: 100%; display: flex; flex-wrap: wrap; justify-content: flex-start; margin-left:0; margin-top: 5px; }
            .top-nav-bar .nav-links a { margin: 3px 10px 3px 0; }
            .game-container { width: 95vw; padding: 15px;}
            #score-area {font-size: 20px;}
            .game-info-section { width: 95vw; padding: 15px;}
            .footer-social-links img { width: 28px; height: 28px;}
        }
    </style>
</head>
<body>
    <nav class="top-nav-bar">
        <div class="logo"><a href="index.html">GameVerse</a></div>
        <div class="nav-links">
            <a href="index.html">Home</a>
            <a href="about.html">About Us</a>
            <a href="contact.html">Contact Us</a>
            <a href="privacy_policy.html">Privacy Policy</a>
            <a href="terms.html">Terms of Service</a> 
        </div>
    </nav>

    <audio id="menu-music" loop src="background music.mp3"></audio>
    <audio id="game-music" loop src="background music 2.mp3"></audio>
    <audio id="drag-sound" loop src="gear.mp3"></audio>
    <audio id="drop-sound" src="drop object.mp3"></audio>
    <audio id="line-clear-sound" src="line clear.mp3"></audio>

    <div class="game-container">
        <div id="combo-popup-message" class="combo-popup"></div>

        <div id="start-screen" class="screen active">
            <h1>Wood Block Puzzle</h1>
            <p style="color: var(--game-text-light); font-size:1.1em; margin-bottom:15px;">A classic brain-teasing block puzzle. Fit the pieces, clear lines, and challenge your high score!</p>
            <button id="start-game-btn">Start Game</button>
        </div>

        <div id="difficulty-screen" class="screen">
            <h2 style="margin-bottom:5px;">Select Difficulty</h2>
            <p style="color: var(--game-text-light); font-size:0.9em; margin-bottom:15px;">Choose your challenge level.</p>
            <button class="difficulty-btn" data-difficulty="easy">Easy</button>
            <button class="difficulty-btn" data-difficulty="medium">Medium</button>
            <button class="difficulty-btn" data-difficulty="hard">Hard</button>

            <div class="music-controls">
                <h3>Music Volume</h3>
                <div class="volume-control-container">
                    <input type="range" id="volume-slider" min="0" max="1" step="0.01" value="0.5">
                </div>
            </div>
        </div>

        <div id="game-screen" class="screen">
            <div id="game-header">
                 <button id="back-to-difficulty-btn">< Back</button>
                 <div id="score-area">Score: <span id="score">0</span></div>
            </div>
            <div id="game-board"></div>
            <div id="piece-container">
                <div class="piece-slot" id="slot-0"></div>
                <div class="piece-slot" id="slot-1"></div>
                <div class="piece-slot" id="slot-2"></div>
            </div>
            <div id="game-over-message" style="display:none;">
                <!-- Content dynamically set by gameOver() -->
            </div>
        </div>
    </div>

    <section class="game-info-section">
        <h2>The Enduring Charm of Wood Block Puzzle</h2>
        <p>Welcome to GameVerse's rendition of the Wood Block Puzzle, a timeless and universally loved brain teaser! This game, with its simple yet profoundly engaging mechanics, offers a delightful challenge to players of all ages. It's not just about fitting pieces; it's an exercise in foresight, spatial reasoning, and strategic planning, all wrapped in a charmingly rustic wooden aesthetic. Our version aims to provide a smooth, intuitive, and satisfying puzzle experience, perfect for a quick mental break or an extended session of thoughtful block placement. Get ready to immerse yourself in the satisfying world of clearing lines and chasing high scores!</p>

        <h3>How to Play: A Beginner's Guide to Block Mastery</h3>
        <p>Getting started with Wood Block Puzzle is incredibly easy, but mastering its nuances will keep you engaged for hours. Here’s a step-by-step guide:</p>
        <ol>
            <li><strong>The Game Board:</strong> You are presented with a 10x10 grid, your canvas for building and clearing lines.</li>
            <li><strong>The Pieces:</strong> Below the grid, you'll find three wooden block pieces of various shapes, inspired by classic tetrominoes and other polyominoes. These are the tools you'll use to fill the board.</li>
            <li><strong>Placing Blocks:</strong> To make a move, simply tap (or click and drag on desktop) one of the three available pieces and move it onto an empty space on the game board. The piece must fit entirely within the unoccupied cells. Once you're happy with the position, release to place it.</li>
            <li><strong>Clearing Lines:</strong> The primary objective is to create complete horizontal or vertical lines of blocks across the grid. When a line is entirely filled with no gaps, it will be cleared from the board, earning you points and, crucially, freeing up valuable space for more pieces.</li>
            <li><strong>Receiving New Pieces:</strong> After you place a piece, it disappears from its slot. If it was from slot 0 or 1, the remaining pieces may shift, and a "hint" piece (visible in slot 2) will become available in the next open slot. When all three initial pieces are used, a new set of three pieces will be generated for you to place. Always keep an eye on the upcoming hint piece!</li>
            <li><strong>No Rotations:</strong> In this classic version, pieces cannot be rotated. You must use them in the orientation they are presented. This adds an extra layer of strategic challenge.</li>
            <li><strong>The End of the Game:</strong> The game concludes when there is no legal move left on the board for any of the three currently available pieces. This means no piece can fit into the remaining empty spaces. At this point, your final score is tallied.</li>
            <li><strong>Scoring System:</strong> You earn points for every individual block cell you place on the board. Clearing a single line grants a significant point bonus. Clearing multiple lines simultaneously (a "combo") results in substantially higher bonus points – aim for these for a top score! The chosen difficulty level also applies a multiplier to your score.</li>
        </ol>

        <h3>Key Features of GameVerse Wood Block Puzzle</h3>
        <ul>
            <li><strong>Multiple Difficulty Levels:</strong> Catering to all players, choose from Easy (more forgiving piece sets, potentially), Medium (a balanced challenge), or Hard (more complex or larger pieces might appear more frequently, testing your limits).</li>
            <li><strong>Intuitive Drag & Drop Controls:</strong> Effortlessly move and place blocks with smooth and responsive touch/mouse controls.</li>
            <li><strong>Satisfying Visuals & Sounds:</strong> Enjoy the clean wooden aesthetic, complemented by pleasing sound effects for piece placement and line clears. An immersive experience with adjustable music volume.</li>
            <li><strong>No Time Pressure:</strong> Play at your own relaxed pace. This is a game of thoughtful strategy, not a race against the clock, allowing for careful planning.</li>
            <li><strong>High Score System:</strong> Challenge yourself to beat your personal best! High scores are saved locally in your browser for each difficulty level, encouraging replayability.</li>
            <li><strong>Exciting Combo Rewards:</strong> Clearing multiple lines in a single move not only boosts your score dramatically but also triggers encouraging on-screen messages like "Good!", "Very Good!", or "Excellent!"</li>
            <li><strong>Dynamic Piece Generation:</strong> A fair but challenging system of piece generation keeps the game interesting and requires adaptability.</li>
            <li><strong>Engaging Line Clear Animation:</strong> A cool "destroy" effect for when lines are cleared, adding to the satisfaction.</li>
        </ul>

        <h3>Advanced Tips & Strategies for Becoming a Puzzle Pro</h3>
        <p>Ready to take your Wood Block Puzzle skills to the next level? Here are some advanced tactics:</p>
        <ul>
            <li><strong>Board Vision & Planning:</strong> Don't just focus on the current three pieces. Constantly scan the entire board for potential line clears several moves ahead. Visualize how upcoming pieces (including the hint piece) might fit.</li>
            <li><strong>Creating "Tetrises" (Multi-Line Clears):</strong> Actively try to leave long, open channels (ideally 4+ cells wide or tall) to set up for clearing multiple lines with a single long "I" piece or strategically placed L/T pieces. This yields the highest scores.</li>
            <li><strong>Corner and Edge Management:</strong> Be wary of creating isolated empty cells in corners or along edges, as these can be very difficult to fill later. Try to keep your block structures relatively flat or with easily accessible gaps.</li>
            <li><strong>Managing "Awkward" Pieces:</strong> Some pieces (like the 2x2 square or larger, more complex shapes) can be tricky. Try to use them as soon as a good opportunity arises, rather than letting them clog your available piece slots if your board is getting tight.</li>
            <li><strong>Strategic Sacrifices:</strong> Sometimes, placing a piece in a slightly suboptimal position is necessary to open up a crucial line clear on the next move or to make space for a much-needed larger piece you see coming in the hint slot.</li>
            <li><strong>Maintaining Flexibility:</strong> Avoid building yourself into a corner where only one specific (and rare) piece can save you. Keep multiple options open by maintaining diverse empty space configurations.</li>
            <li><strong>The "Well" Strategy (for advanced players):</strong> Some players try to build up blocks on most of the board while leaving one column (the "well") mostly empty, aiming to clear multiple lines repeatedly with "I" pieces. This is high-risk, high-reward.</li>
            <li><strong>Learn from Mistakes:</strong> If a game ends prematurely, try to identify the move or series of moves that led to the board becoming unplayable. Each game is a learning opportunity.</li>
        </ul>
         <p>The Wood Block Puzzle on GameVerse offers a perfect blend of simplicity and strategic depth. It’s an ideal way to relax, de-stress, and give your brain a stimulating workout. Dive in, start placing those blocks, and see how high you can score. Happy puzzling!</p>
    </section>

    <footer class="site-footer">
        <p>© <span id="currentYear"></span> GameVerse by Kanhaiya Mishra. All Rights Reserved.</p>
        <div class="footer-links-group">
            <a href="index.html">Home</a> | 
            <a href="about.html">About Us</a> | 
            <a href="contact.html">Contact Us</a> | 
            <a href="privacy_policy.html">Privacy Policy</a> |
            <a href="terms.html">Terms of Service</a>
        </div>
        <div class="footer-social-links">
            <p>Follow Us for GameVerse Updates:</p>
            <a href="https://t.me/PraxAI" target="_blank" rel="noopener noreferrer" title="PraxAI on Telegram">
                <img src="telegram-icon.png" alt="Telegram Icon for GameVerse">
            </a>
            <a href="https://youtube.com/@praxai?si=SrIQNBLVw79p9oKD" target="_blank" rel="noopener noreferrer" title="PraxAI on YouTube">
                <img src="youtube-icon.png" alt="YouTube Icon for GameVerse">
            </a>
            <a href="https://whatsapp.com/channel/0029Vb30cphDjiOZoEQf9a20" target="_blank" rel="noopener noreferrer" title="Gyan Natraj on WhatsApp">
                <img src="whatsapp-icon.png" alt="WhatsApp Channel Icon for GameVerse">
            </a>
        </div>
    </footer>

    <script>
        // PASTE THE ENTIRE ORIGINAL JAVASCRIPT FOR THE WOODEN PUZZLE GAME HERE
        // (The one that starts with "const GRID_SIZE = 10;")
        // No changes should be made to the game logic JavaScript itself.

        const GRID_SIZE = 10;
        const gameBoardElement = document.getElementById('game-board');
        const scoreElement = document.getElementById('score');
        const pieceSlots = [
            document.getElementById('slot-0'),
            document.getElementById('slot-1'),
            document.getElementById('slot-2')
        ];

        const startScreen = document.getElementById('start-screen');
        const difficultyScreen = document.getElementById('difficulty-screen');
        const gameScreen = document.getElementById('game-screen');
        const gameOverMessageDiv = document.getElementById('game-over-message');
        const comboPopupMessageElement = document.getElementById('combo-popup-message');
        const backToDifficultyBtn = document.getElementById('back-to-difficulty-btn');


        const menuMusic = document.getElementById('menu-music');
        const gameMusic = document.getElementById('game-music');
        const dragSound = document.getElementById('drag-sound');
        const dropSound = document.getElementById('drop-sound');
        const lineClearSound = document.getElementById('line-clear-sound');
        const volumeSlider = document.getElementById('volume-slider');

        let board = [];
        let score = 0;
        let currentPieces = [null, null, null];
        let difficulty = 'medium';
        let difficultyMultipliers = { easy: 0.8, medium: 1, hard: 1.3 };
        const HIGH_SCORE_KEY = 'woodBlockPuzzleHighScore';


        const PIECES = {
            SINGLE: { shape: [[1]], id: 'SINGLE' }, DOMINO1X2_H: { shape: [[1,1]], id: 'DOMINO1X2_H' },
            DOMINO1X2_V: { shape: [[1],[1]], id: 'DOMINO1X2_V' }, SQUARE2X2: { shape: [[1,1],[1,1]], id: 'SQUARE2X2' },
            CORNER_A: { shape: [[1,1],[1,0]], id: 'CORNER_A'}, CORNER_B: { shape: [[1,1],[0,1]], id: 'CORNER_B'},
            I3_H: { shape: [[1,1,1]], id: 'I3_H' }, I3_V: { shape: [[1],[1],[1]], id: 'I3_V' },
            L_SHAPE_A: { shape: [[1,0],[1,0],[1,1]], id: 'L_SHAPE_A' }, L_SHAPE_B: { shape: [[1,1],[1,0],[1,0]], id: 'L_SHAPE_B' },
            T_SHAPE: { shape: [[1,1,1],[0,1,0]], id: 'T_SHAPE' }, S_SHAPE: { shape: [[0,1,1],[1,1,0]], id: 'S_SHAPE' },
            Z_SHAPE: { shape: [[1,1,0],[0,1,1]], id: 'Z_SHAPE' }, U_SHAPE_3X2: { shape: [[1,0,1],[1,1,1]], id: 'U_SHAPE_3X2'},
            C_SHAPE_3X2_A: { shape: [[1,1],[1,0],[1,1]], id: 'C_SHAPE_3X2_A' }, C_SHAPE_3X2_B: { shape: [[1,1],[0,1],[1,1]], id: 'C_SHAPE_3X2_B' },
            SMALL_HAT_V: { shape: [[1,0],[1,1],[1,0]], id: 'SMALL_HAT_V' }, I4_H: { shape: [[1,1,1,1]], id: 'I4_H' },
            I4_V: { shape: [[1],[1],[1],[1]], id: 'I4_V' }, L_LARGE_A: { shape: [[1,0],[1,0],[1,0],[1,1]], id: 'L_LARGE_A' },
            L_LARGE_B: { shape: [[0,1],[0,1],[0,1],[1,1]], id: 'L_LARGE_B' }, SQUARE3X3: { shape: [[1,1,1],[1,1,1],[1,1,1]], id: 'SQUARE3X3'},
            HOLLOW_SQUARE_3X3: { shape: [[1,1,1],[1,0,1],[1,1,1]], id: 'HOLLOW_SQUARE_3X3'},
            CROSS_5_HIGH: {shape: [[0,1,0],[0,1,0],[1,1,1],[0,1,0],[0,1,0]], id: 'CROSS_5_HIGH'},
            CROSS_3H_5W: {shape: [[0,0,1,0,0],[1,1,1,1,1],[0,0,1,0,0]], id: 'CROSS_3H_5W'},
            AWKWARD_ANGLE_A: { shape: [[1,1,0],[0,1,1],[0,0,1]], id: 'AWKWARD_ANGLE_A'},
            AWKWARD_ANGLE_B: { shape: [[0,1,1],[1,1,0],[1,0,0]], id: 'AWKWARD_ANGLE_B'},
            I5_H: { shape: [[1,1,1,1,1]], id: 'I5_H' }, I5_V: { shape: [[1],[1],[1],[1],[1]], id: 'I5_V' },
        };

        const NEW_EASY_PIECE_KEYS_POOL = [
            'SINGLE', 'SINGLE', 'SINGLE', 'SINGLE', 'SINGLE', 'SINGLE', 'SINGLE', 'SINGLE', 'SINGLE', 'SINGLE',
            'DOMINO1X2_H', 'DOMINO1X2_H', 'DOMINO1X2_H', 'DOMINO1X2_H', 'DOMINO1X2_H',
            'DOMINO1X2_V', 'DOMINO1X2_V', 'DOMINO1X2_V', 'DOMINO1X2_V', 'DOMINO1X2_V',
            'SQUARE2X2', 'SQUARE2X2', 'SQUARE2X2', 'SQUARE2X2',
            'CORNER_A', 'CORNER_A', 'CORNER_B', 'CORNER_B', 'I3_H', 'I3_V'
        ];
        const NEW_MEDIUM_PIECE_KEYS_POOL = [
            'SINGLE', 'DOMINO1X2_H', 'DOMINO1X2_V', 'SQUARE2X2', 'SQUARE2X2',
            'CORNER_A', 'CORNER_A', 'CORNER_B', 'CORNER_B', 'I3_H', 'I3_H', 'I3_V', 'I3_V',
            'L_SHAPE_A', 'L_SHAPE_A', 'L_SHAPE_B', 'L_SHAPE_B', 'T_SHAPE', 'T_SHAPE', 'T_SHAPE',
            'S_SHAPE', 'S_SHAPE', 'Z_SHAPE', 'Z_SHAPE', 'U_SHAPE_3X2',
            'C_SHAPE_3X2_A', 'C_SHAPE_3X2_B', 'SMALL_HAT_V', 'I4_H', 'I4_V'
        ];
        const NEW_HARD_PIECE_KEYS_POOL = [
            'I3_H', 'I3_V', 'L_SHAPE_A', 'L_SHAPE_B', 'T_SHAPE', 'T_SHAPE',
            'S_SHAPE', 'S_SHAPE', 'Z_SHAPE', 'Z_SHAPE', 'U_SHAPE_3X2', 'U_SHAPE_3X2',
            'C_SHAPE_3X2_A', 'C_SHAPE_3X2_B', 'SMALL_HAT_V', 'SMALL_HAT_V',
            'I4_H', 'I4_H', 'I4_V', 'I4_V', 'L_LARGE_A', 'L_LARGE_A',
            'L_LARGE_B', 'L_LARGE_B', 'SQUARE3X3', 'HOLLOW_SQUARE_3X3',
            'CROSS_5_HIGH', 'CROSS_3H_5W', 'AWKWARD_ANGLE_A', 'AWKWARD_ANGLE_B', 'I5_H', 'I5_V'
        ];

        let easyPieceBag = [];
        let mediumPieceBag = [];
        let hardPieceBag = [];

        let isDragging = false;
        let draggedPieceData = null;
        let draggedPieceCloneElement = null;
        let originalPieceElement = null;
        let dragOffsetX = 0;
        let dragOffsetY = 0;
        let mainCellSize = 30; 
        const PIECE_PREVIEW_CELL_SIZE = 18;
        const LINE_CLEAR_ANIMATION_DURATION = 400; 
        let comboPopupTimeout = null;


        function playSound(soundElement, loop = false) {
            if (soundElement) {
                soundElement.loop = loop;
                soundElement.currentTime = 0;
                soundElement.play().catch(e => console.warn("Sound play failed:", e));
            }
        }

        function stopSound(soundElement) {
            if(soundElement){
                soundElement.pause();
                soundElement.currentTime = 0;
            }
        }

        function showComboPopup(message) {
            if (comboPopupTimeout) clearTimeout(comboPopupTimeout);

            comboPopupMessageElement.textContent = message;
            comboPopupMessageElement.classList.remove('hide');
            comboPopupMessageElement.classList.add('show');

            comboPopupTimeout = setTimeout(() => {
                comboPopupMessageElement.classList.remove('show');
                comboPopupMessageElement.classList.add('hide');
            }, 1500); 
        }


        function initGame() {
            document.getElementById('start-game-btn').addEventListener('click', () => {
                 showDifficultyScreen();
                 if (parseFloat(volumeSlider.value) > 0 && menuMusic.paused) {
                     menuMusic.play().catch(e => console.warn("Menu music play failed on start button:", e));
                 }
            });
            document.querySelectorAll('.difficulty-btn').forEach(btn => {
                btn.addEventListener('click', (e) => selectDifficulty(e.target.dataset.difficulty));
            });

            backToDifficultyBtn.addEventListener('click', () => {
                gameMusic.pause();
                if (parseFloat(volumeSlider.value) > 0 && menuMusic.paused) {
                    menuMusic.play().catch(e => console.warn("Menu music play failed on back button:", e));
                }
                showDifficultyScreen();
            });

            createBoardCells();
            const initialVolume = parseFloat(volumeSlider.value);
            menuMusic.volume = initialVolume;
            gameMusic.volume = initialVolume;
            dragSound.volume = initialVolume;
            dropSound.volume = initialVolume;
            lineClearSound.volume = initialVolume;


            if (initialVolume == 0) {
                menuMusic.pause();
                gameMusic.pause();
            }
            volumeSlider.addEventListener('input', (e) => {
                const newVolume = parseFloat(e.target.value);
                menuMusic.volume = newVolume;
                gameMusic.volume = newVolume;
                dragSound.volume = newVolume;
                dropSound.volume = newVolume;
                lineClearSound.volume = newVolume;

                if (newVolume > 0) {
                    if (gameScreen.classList.contains('active') && gameMusic.paused) {
                        gameMusic.play().catch(error => console.warn("Game music play failed on slider change:", error));
                    } else if ((startScreen.classList.contains('active') || difficultyScreen.classList.contains('active')) && menuMusic.paused) {
                         menuMusic.play().catch(error => console.warn("Menu music play failed on slider change:", error));
                    }
                } else {
                    menuMusic.pause();
                    gameMusic.pause();
                }
            });
            document.getElementById('currentYear').textContent = new Date().getFullYear();
        }

        function showStartScreen() {
            startScreen.classList.add('active');
            difficultyScreen.classList.remove('active');
            gameScreen.classList.remove('active');
            gameOverMessageDiv.style.display = 'none';
            if(!gameMusic.paused) gameMusic.pause();
            if (parseFloat(volumeSlider.value) > 0 && menuMusic.paused) {
                menuMusic.play().catch(e => console.warn("Menu music play on showStartScreen failed:", e));
            }
        }

        function showDifficultyScreen() {
            startScreen.classList.remove('active');
            difficultyScreen.classList.add('active');
            gameScreen.classList.remove('active');
            gameOverMessageDiv.style.display = 'none';
            if(!gameMusic.paused) gameMusic.pause();
            if (parseFloat(volumeSlider.value) > 0 && menuMusic.paused) {
                menuMusic.play().catch(e => console.warn("Menu music play on showDifficultyScreen failed:", e));
            }
        }

        function selectDifficulty(selectedDifficulty) {
            difficulty = selectedDifficulty;
            easyPieceBag = []; 
            mediumPieceBag = [];
            hardPieceBag = [];
            if(!menuMusic.paused) menuMusic.pause();
            if (parseFloat(volumeSlider.value) > 0 && gameMusic.paused) {
                 const playPromise = gameMusic.play();
                 if (playPromise !== undefined) {
                    playPromise.catch(error => console.warn("Game music play on game start failed:", error));
                 }
            }
            startGame();
        }

        function startGame() {
            showGameScreen();
            board = Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(0));
            score = 0;
            updateScoreDisplay();
            renderBoard(); 
            const firstGridCell = gameBoardElement.querySelector('.grid-cell');
            if (firstGridCell) {
                 mainCellSize = firstGridCell.offsetWidth;
            } else {
                mainCellSize = 30; 
            }
            if(isNaN(mainCellSize) || mainCellSize <= 0) mainCellSize = 30; 

            initialFillAllSlots();
            gameOverMessageDiv.style.display = 'none';
        }

        function showGameScreen() {
            startScreen.classList.remove('active');
            difficultyScreen.classList.remove('active');
            gameScreen.classList.add('active');
            gameOverMessageDiv.style.display = 'none';
        }

        function createBoardCells() {
            gameBoardElement.innerHTML = '';
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    const cell = document.createElement('div');
                    cell.classList.add('grid-cell');
                    cell.dataset.r = r;
                    cell.dataset.c = c;
                    gameBoardElement.appendChild(cell);
                }
            }
        }
        function renderBoard() {
             for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    const cellElement = gameBoardElement.children[r * GRID_SIZE + c];
                    if (board[r][c] === 1) {
                        cellElement.classList.add('filled');
                    } else {
                        cellElement.classList.remove('filled');
                    }
                    cellElement.classList.remove('line-clearing');
                }
            }
        }

        function getPieceKeyFromBag(difficultyLevel) {
            let targetBag;
            let sourcePool;
            let pieceBagRef; 

            if (difficultyLevel === 'easy') {
                targetBag = easyPieceBag; sourcePool = NEW_EASY_PIECE_KEYS_POOL; pieceBagRef = 'easyPieceBag';
            } else if (difficultyLevel === 'medium') {
                targetBag = mediumPieceBag; sourcePool = NEW_MEDIUM_PIECE_KEYS_POOL; pieceBagRef = 'mediumPieceBag';
            } else if (difficultyLevel === 'hard') {
                targetBag = hardPieceBag; sourcePool = NEW_HARD_PIECE_KEYS_POOL; pieceBagRef = 'hardPieceBag';
            } else { 
                targetBag = mediumPieceBag; sourcePool = NEW_MEDIUM_PIECE_KEYS_POOL; pieceBagRef = 'mediumPieceBag';
            }

            if (targetBag.length === 0) {
                if (!sourcePool || sourcePool.length === 0) return 'SINGLE'; 
                
                if (pieceBagRef === 'easyPieceBag') easyPieceBag.push(...[...sourcePool]);
                else if (pieceBagRef === 'mediumPieceBag') mediumPieceBag.push(...[...sourcePool]);
                else if (pieceBagRef === 'hardPieceBag') hardPieceBag.push(...[...sourcePool]);
                
                if (pieceBagRef === 'easyPieceBag') targetBag = easyPieceBag;
                else if (pieceBagRef === 'mediumPieceBag') targetBag = mediumPieceBag;
                else if (pieceBagRef === 'hardPieceBag') targetBag = hardPieceBag;
            }
            if (targetBag.length === 0) return 'SINGLE'; 

            const randomIndex = Math.floor(Math.random() * targetBag.length);
            return targetBag.splice(randomIndex, 1)[0];
        }

        function generateRandomPieceData(targetSlotIndex) {
            const randomPieceKey = getPieceKeyFromBag(difficulty);
            if (!PIECES[randomPieceKey]) {
                console.error("Invalid piece key generated:", randomPieceKey, "Falling back to SINGLE.");
                return { piece: PIECES['SINGLE'], shape: PIECES['SINGLE'].shape, slotIndex: targetSlotIndex };
            }
            return {
                piece: PIECES[randomPieceKey],
                shape: PIECES[randomPieceKey].shape,
                slotIndex: targetSlotIndex
            };
        }

        function initialFillAllSlots() {
            for (let i = 0; i < 3; i++) {
                currentPieces[i] = generateRandomPieceData(i);
                renderPieceInSlot(currentPieces[i], pieceSlots[i]);
            }
            checkGameOver();
        }

        function renderPieceInSlot(pieceData, slotElement) {
            slotElement.innerHTML = '';
            if (!pieceData) return;
            const pieceElement = document.createElement('div');
            pieceElement.classList.add('piece');
            const shape = pieceData.shape;
            pieceElement.style.gridTemplateRows = `repeat(${shape.length}, 1fr)`;
            pieceElement.style.gridTemplateColumns = `repeat(${shape[0].length}, 1fr)`;

            for (let r_shape = 0; r_shape < shape.length; r_shape++) {
                for (let c_shape = 0; c_shape < shape[0].length; c_shape++) {
                    const cell = document.createElement('div');
                    cell.classList.add('piece-cell');
                    if (shape[r_shape][c_shape] === 0) {
                        cell.classList.add('empty');
                    }
                    pieceElement.appendChild(cell);
                }
            }

            if (pieceData.slotIndex === 2) { 
                pieceElement.classList.add('hint-piece');
            } else { 
                pieceElement.addEventListener('pointerdown', (e) => onPiecePointerDown(e, pieceData, pieceElement));
            }
            slotElement.appendChild(pieceElement);
        }

        function shiftAndRefillPieces(usedSlotIndex) {
            if (usedSlotIndex === 0) { 
                currentPieces[0] = currentPieces[1]; 
                if (currentPieces[0]) currentPieces[0].slotIndex = 0;

                currentPieces[1] = currentPieces[2]; 
                if (currentPieces[1]) currentPieces[1].slotIndex = 1;

            } else if (usedSlotIndex === 1) { 
                currentPieces[1] = currentPieces[2]; 
                if (currentPieces[1]) currentPieces[1].slotIndex = 1;
            }
            currentPieces[2] = generateRandomPieceData(2);

            renderPieceInSlot(currentPieces[0], pieceSlots[0]);
            renderPieceInSlot(currentPieces[1], pieceSlots[1]);
            renderPieceInSlot(currentPieces[2], pieceSlots[2]); 

            checkGameOver(); 
        }

        function onPiecePointerDown(event, pieceData, pieceElement) {
            if (isDragging || event.button !== 0 || pieceData.slotIndex === 2) return; 
            event.preventDefault();

            playSound(dragSound, true);

            isDragging = true;
            draggedPieceData = pieceData;
            originalPieceElement = pieceElement;
            const rect = pieceElement.getBoundingClientRect();
            dragOffsetX = event.clientX - rect.left;
            dragOffsetY = event.clientY - rect.top;
            
            const scaleFactor = mainCellSize / PIECE_PREVIEW_CELL_SIZE;

            draggedPieceCloneElement = pieceElement.cloneNode(true);
            draggedPieceCloneElement.classList.add('piece-clone');
            draggedPieceCloneElement.style.width = `${pieceElement.offsetWidth * scaleFactor}px`;
            draggedPieceCloneElement.style.height = `${pieceElement.offsetHeight * scaleFactor}px`;

            const cloneCells = draggedPieceCloneElement.querySelectorAll('.piece-cell');
            cloneCells.forEach(cell => {
                 if(!cell.classList.contains('empty')) { 
                    cell.style.width = `${mainCellSize}px`;
                    cell.style.height = `${mainCellSize}px`;
                 }
            });
            
            document.body.appendChild(draggedPieceCloneElement);
            document.body.classList.add('dragging-active');
            
            draggedPieceCloneElement.style.left = `${event.clientX - (dragOffsetX * scaleFactor)}px`;
            draggedPieceCloneElement.style.top = `${event.clientY - (dragOffsetY * scaleFactor)}px`;
            
            originalPieceElement.classList.add('is-being-dragged'); 
            
            document.addEventListener('pointermove', onDocumentPointerMove);
            document.addEventListener('pointerup', onDocumentPointerUp);
            document.addEventListener('pointercancel', onDocumentPointerUp);
        }

        function onDocumentPointerMove(event) {
            if (!isDragging || !draggedPieceCloneElement) return;
            event.preventDefault();
            const scaleFactor = mainCellSize / PIECE_PREVIEW_CELL_SIZE;
            const currentX = event.clientX - (dragOffsetX * scaleFactor);
            const currentY = event.clientY - (dragOffsetY * scaleFactor);
            draggedPieceCloneElement.style.left = `${currentX}px`;
            draggedPieceCloneElement.style.top = `${currentY}px`;

            const gameBoardRect = gameBoardElement.getBoundingClientRect();
            
            const cloneRect = draggedPieceCloneElement.getBoundingClientRect();
            let boardRelativeX = cloneRect.left - gameBoardRect.left;
            let boardRelativeY = cloneRect.top - gameBoardRect.top;

            let potentialDropR = Math.floor((boardRelativeY + mainCellSize / 2) / mainCellSize);
            let potentialDropC = Math.floor((boardRelativeX + mainCellSize / 2) / mainCellSize);

            clearPreview();
            if (draggedPieceData && canPlacePiece(draggedPieceData.shape, potentialDropR, potentialDropC)) {
                drawPreview(draggedPieceData.shape, potentialDropR, potentialDropC);
            }
        }

        async function onDocumentPointerUp(event) {
            if (!isDragging) return;

            stopSound(dragSound);

            document.removeEventListener('pointermove', onDocumentPointerMove);
            document.removeEventListener('pointerup', onDocumentPointerUp);
            document.removeEventListener('pointercancel', onDocumentPointerUp);
            document.body.classList.remove('dragging-active');

            let piecePlacedSuccessfully = false;

            if (draggedPieceCloneElement && draggedPieceData) {
                const gameBoardRect = gameBoardElement.getBoundingClientRect();
                
                const cloneRect = draggedPieceCloneElement.getBoundingClientRect();
                let boardRelativeX = cloneRect.left - gameBoardRect.left;
                let boardRelativeY = cloneRect.top - gameBoardRect.top;

                let dropR = Math.floor((boardRelativeY + mainCellSize / 2) / mainCellSize);
                let dropC = Math.floor((boardRelativeX + mainCellSize / 2) / mainCellSize);
                
                if (canPlacePiece(draggedPieceData.shape, dropR, dropC)) {
                    piecePlacedSuccessfully = true;
                    playSound(dropSound);
                    placePiece(draggedPieceData.shape, dropR, dropC);
                    addScore(draggedPieceData.shape.flat().reduce((sum, val) => sum + val, 0) * 5);
                    
                    const usedSlotOriginalIndex = draggedPieceData.slotIndex;
                    currentPieces[usedSlotOriginalIndex] = null; 
                    
                    const linesClearedInfo = await clearLines(); 
                    renderBoard(); 

                    if (linesClearedInfo.totalLines > 0) {
                        if (linesClearedInfo.totalLines >= 4) { 
                            showComboPopup("Excellent!");
                        } else if (linesClearedInfo.totalLines === 3) {
                            showComboPopup("Very Good!");
                        } else if (linesClearedInfo.totalLines === 2) {
                            showComboPopup("Good!");
                        } else if (linesClearedInfo.totalLines === 1) {
                             showComboPopup("Great!"); 
                        }
                    }
                    shiftAndRefillPieces(usedSlotOriginalIndex);
                }
            }

            if (draggedPieceCloneElement) {
                draggedPieceCloneElement.remove();
                draggedPieceCloneElement = null;
            }
            if (originalPieceElement) {
                originalPieceElement.classList.remove('is-being-dragged');
                if (!piecePlacedSuccessfully && originalPieceElement.parentElement) { 
                    originalPieceElement.style.opacity = '1'; 
                } else if (!piecePlacedSuccessfully && !originalPieceElement.parentElement) {
                    if(draggedPieceData) renderPieceInSlot(draggedPieceData, pieceSlots[draggedPieceData.slotIndex]);
                }
            }
            clearPreview();

            isDragging = false;
            draggedPieceData = null;
            originalPieceElement = null;
            
            if (piecePlacedSuccessfully) checkGameOver();
        }
        function clearPreview() {
            document.querySelectorAll('.grid-cell.preview').forEach(cell => cell.classList.remove('preview'));
        }
        function drawPreview(shape, startR, startC) {
            for (let rOffset = 0; rOffset < shape.length; rOffset++) {
                for (let cOffset = 0; cOffset < shape[0].length; cOffset++) {
                    if (shape[rOffset][cOffset] === 1) {
                        const boardR = startR + rOffset;
                        const boardC = startC + cOffset;
                        if (boardR >= 0 && boardR < GRID_SIZE && boardC >= 0 && boardC < GRID_SIZE) {
                           const cellEl = gameBoardElement.children[boardR * GRID_SIZE + boardC];
                           if (cellEl && !cellEl.classList.contains('filled')) {
                                cellEl.classList.add('preview');
                           }
                        }
                    }
                }
            }
        }
        function canPlacePiece(shape, startR, startC) {
            for (let rOffset = 0; rOffset < shape.length; rOffset++) {
                for (let cOffset = 0; cOffset < shape[0].length; cOffset++) {
                    if (shape[rOffset][cOffset] === 1) {
                        const boardR = startR + rOffset;
                        const boardC = startC + cOffset;
                        if (boardR >= GRID_SIZE || boardC >= GRID_SIZE || boardR < 0 || boardC < 0 || board[boardR][boardC] === 1) {
                            return false;
                        }
                    }
                }
            }
            return true;
        }
        function placePiece(shape, startR, startC) {
            for (let rOffset = 0; rOffset < shape.length; rOffset++) {
                for (let cOffset = 0; cOffset < shape[0].length; cOffset++) {
                    if (shape[rOffset][cOffset] === 1) {
                        board[startR + rOffset][startC + cOffset] = 1;
                    }
                }
            }
        }

        async function clearLines() {
            let rowsToClear = [];
            let colsToClear = [];
            let cellsToAnimateElements = [];

            for (let r = 0; r < GRID_SIZE; r++) {
                if (board[r].every(cell => cell === 1)) {
                    rowsToClear.push(r);
                    for (let c = 0; c < GRID_SIZE; c++) {
                        cellsToAnimateElements.push(gameBoardElement.children[r * GRID_SIZE + c]);
                    }
                }
            }

            for (let c = 0; c < GRID_SIZE; c++) {
                let colFull = true;
                for (let r = 0; r < GRID_SIZE; r++) {
                    if (board[r][c] === 0) {
                        colFull = false;
                        break;
                    }
                }
                if (colFull) {
                    colsToClear.push(c);
                    for (let r = 0; r < GRID_SIZE; r++) {
                        const cellElement = gameBoardElement.children[r * GRID_SIZE + c];
                        if (!cellsToAnimateElements.includes(cellElement)) {
                            cellsToAnimateElements.push(cellElement);
                        }
                    }
                }
            }

            const totalLinesCleared = rowsToClear.length + colsToClear.length;

            if (cellsToAnimateElements.length > 0) {
                playSound(lineClearSound);
                cellsToAnimateElements.forEach(cellEl => cellEl.classList.add('line-clearing'));

                await new Promise(resolve => setTimeout(resolve, LINE_CLEAR_ANIMATION_DURATION));

                rowsToClear.forEach(r => {
                    for (let c = 0; c < GRID_SIZE; c++) board[r][c] = 0;
                });
                colsToClear.forEach(c => {
                    for (let r = 0; r < GRID_SIZE; r++) board[r][c] = 0;
                });
                
                if (totalLinesCleared > 0) {
                    let lineScore = 0;
                    if (totalLinesCleared === 1) lineScore = 100;
                    else if (totalLinesCleared === 2) lineScore = 300; 
                    else if (totalLinesCleared === 3) lineScore = 600; 
                    else if (totalLinesCleared >= 4) lineScore = 1000 + (totalLinesCleared - 4) * 500;
                    addScore(lineScore);
                }
            }
            return { totalLines: totalLinesCleared };
        }


        function addScore(points) {
            score += Math.round(points * difficultyMultipliers[difficulty]);
            updateScoreDisplay();
        }
        function updateScoreDisplay() {
             scoreElement.textContent = score;
        }
        function checkGameOver() {
            let canPlaceAnyPlayable = false;
            for (let pieceIdx = 0; pieceIdx < 2; pieceIdx++) { 
                if (currentPieces[pieceIdx]) { 
                    const pieceShape = currentPieces[pieceIdx].shape;
                    for (let r = 0; r < GRID_SIZE; r++) {
                        for (let c = 0; c < GRID_SIZE; c++) {
                            if (canPlacePiece(pieceShape, r, c)) {
                                canPlaceAnyPlayable = true;
                                break; 
                            }
                        }
                        if (canPlaceAnyPlayable) break; 
                    }
                }
                if (canPlaceAnyPlayable) break; 
            }
            
            const hasPlayablePiece = currentPieces[0] !== null || currentPieces[1] !== null;

            if (hasPlayablePiece && !canPlaceAnyPlayable) {
                 gameOver();
            }
        }


        function gameOver() {
            const currentHighScoreKey = HIGH_SCORE_KEY + `_${difficulty}`;
            let highScore = localStorage.getItem(currentHighScoreKey);
            if (highScore === null) {
                highScore = 0;
            } else {
                highScore = parseInt(highScore);
            }

            if (score > highScore) {
                highScore = score;
                localStorage.setItem(currentHighScoreKey, highScore);
            }

            gameOverMessageDiv.innerHTML = `
                <h3>Game Over!</h3>
                <p>Difficulty: ${difficulty.charAt(0).toUpperCase() + difficulty.slice(1)}</p>
                <p>Your Score: ${score}</p>
                <p>High Score (${difficulty}): ${highScore}</p>
                <button id="restart-game-over-btn">Play Again</button>
            `;
            gameOverMessageDiv.style.display = 'block';

            const restartGameOverBtn = document.getElementById('restart-game-over-btn');
            if(restartGameOverBtn){
                restartGameOverBtn.addEventListener('click', () => {
                    gameOverMessageDiv.style.display = 'none';
                    gameMusic.pause();
                    if (parseFloat(volumeSlider.value) > 0 && menuMusic.paused) {
                        menuMusic.play().catch(e => console.warn("Menu music play failed on restart (game over):", e));
                    }
                    showDifficultyScreen(); 
                });
            }

            isDragging = false;
            if (draggedPieceCloneElement) draggedPieceCloneElement.remove();
            document.body.classList.remove('dragging-active');
        }

        initGame();
        showStartScreen();

        // Ensure currentYear is set for the footer on this page too
        // This should ideally be in initGame or a separate function called on page load for all pages.
        // For simplicity, if it's not already in initGame, adding it here again.
        if(document.getElementById('currentYear')) {
            document.getElementById('currentYear').textContent = new Date().getFullYear();
        }
    </script>
</body>
</html>
