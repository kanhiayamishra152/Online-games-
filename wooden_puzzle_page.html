<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wood Block Puzzle - How to Play & Tips | GameVerse</title>
    <meta name="description" content="Play the engaging Wood Block Puzzle game. Learn how to play, get tips for high scores, and enjoy this classic brain teaser on GameVerse.">
    <meta name="keywords" content="wood block puzzle, puzzle game, block puzzle, online puzzle, gameverse, brain game, new games, what is game, how to play, Play Store, google.com, ai, strategy game">

    <!-- Google AdSense Script -->
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8067952496194704"
         crossorigin="anonymous"></script>
    <!-- End Google AdSense Script -->

    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600&family=Roboto+Slab:wght@400;700&display=swap" rel="stylesheet">

    <style>
        :root {
            --gv-top-nav-bg: #2c1e10;
            --gv-top-nav-text: #f5e8d3;
            --gv-top-nav-link-hover-bg: #4a3623;
            --gv-primary-accent: #e8a14d;
        }
        body {
            font-family: 'Poppins', sans-serif;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #654321;
            touch-action: manipulation;
            overflow-x: hidden;
            padding-top: 60px;
        }

        .top-nav-bar {
            position: fixed; top: 0; left: 0; width: 100%;
            background-color: var(--gv-top-nav-bg); 
            color: var(--gv-top-nav-text); padding: 10px 20px;
            display: flex; justify-content: space-between; align-items: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2); z-index: 1010;
        }
        .top-nav-bar .logo a { color: var(--gv-top-nav-text); text-decoration: none; font-size: 1.3em; font-weight: 700; font-family: 'Roboto Slab', serif;}
        .top-nav-bar .nav-links { display: flex; align-items: center; }
        .top-nav-bar .nav-links a { color: var(--gv-top-nav-text); text-decoration: none; margin-left: 15px; font-size: 0.9em; padding: 5px 8px; border-radius: 5px; transition: background-color 0.3s ease; }
        .top-nav-bar .nav-links a:hover { background-color: var(--gv-top-nav-link-hover-bg); }

        .site-footer {
            text-align: center; padding: 20px 0; margin-top: 30px;
            width:100%; background-color: var(--gv-top-nav-bg);
            color: var(--gv-top-nav-text); opacity: 0.9; font-size: 0.9em;
        }
        .site-footer a { color: var(--gv-primary-accent); text-decoration: none;}
        .site-footer a:hover { text-decoration: underline;}

        body.dragging-active { cursor: grabbing; }
        .game-container {
            background-color: #8B4513; padding: 20px; border-radius: 10px;
            box-shadow: 0 0 20px rgba(0,0,0,0.5), inset 0 0 15px rgba(50,20,0,0.7);
            text-align: center; max-width: 90vw; width: 400px; user-select: none;
            -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none;
            position: relative; margin-top: 10px; margin-bottom: 20px;
        }
        .screen { display: none; }
        .screen.active { display: block; }
        #score-area {
            background-color: #A0522D; color: #FFF0E1; font-size: 24px; font-weight: bold;
            padding: 10px 20px; border-radius: 8px; box-shadow: inset 0 2px 4px rgba(0,0,0,0.3);
            border: 2px solid #6B4226; flex-grow: 1; text-align: center;
        }
        #game-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
        #back-to-difficulty-btn {
            background-color: #A0522D; color: #FFF0E1; border: 1px solid #6B4226;
            padding: 5px 10px; font-size: 14px; border-radius: 5px; cursor: pointer;
            box-shadow: 0 2px #6B4226; margin-right: 10px;
        }
        #back-to-difficulty-btn:hover { background-color: #804020; }
        #back-to-difficulty-btn:active { transform: translateY(1px); box-shadow: 0 1px #6B4226; }
        #game-board {
            display: grid; grid-template-columns: repeat(10, 1fr); grid-template-rows: repeat(10, 1fr);
            width: 100%; aspect-ratio: 1 / 1; background-color: #A0522D;
            border: 3px solid #603813; box-shadow: inset 0 0 10px rgba(0,0,0,0.4);
            margin-bottom: 20px; position: relative;
        }
        .grid-cell {
            background-color: #DEB887; border: 1px solid #B8860B;
            box-shadow: inset 1px 1px 2px rgba(0,0,0,0.1), inset -1px -1px 2px rgba(255,255,255,0.2);
            transition: background-color 0.1s;
        }
        .grid-cell.filled {
            background-color: #CD853F; border: 1px solid #8B4513;
            box-shadow: inset 2px 2px 5px rgba(0,0,0,0.3), 0 0 3px rgba(255,222,173,0.5);
        }
        .grid-cell.preview { background-color: rgba(255, 255, 255, 0.5) !important; outline: 1px dashed #333; }
        
        @keyframes destroyEffect {
            0% {
                transform: scale(1);
                opacity: 1;
                background-color: #FFFACD; /* Highlight color */
            }
            50% {
                transform: scale(1.1); 
                opacity: 0.8;
                background-color: #FFD700; /* Brighter highlight */
            }
            100% {
                transform: scale(0.1); 
                opacity: 0;
                background-color: #CD853F; 
            }
        }

        .grid-cell.line-clearing {
            animation: destroyEffect 0.4s ease-out forwards; 
        }

        .combo-popup {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.7); color: white; padding: 15px 30px;
            border-radius: 10px; font-size: 28px; font-weight: bold; z-index: 1001;
            opacity: 0; transition: opacity 0.3s ease-out, transform 0.3s ease-out;
            pointer-events: none;
        }
        .combo-popup.show { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
        .combo-popup.hide { opacity: 0; transform: translate(-50%, -50%) scale(0.9); }
        #game-over-message {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -60%);
            background-color: rgba(139, 69, 19, 0.9); color: #FFF0E1; padding: 25px;
            border-radius: 15px; border: 3px solid #603813; box-shadow: 0 5px 15px rgba(0,0,0,0.4);
            z-index: 1002; text-align: center; width: 80%; max-width: 300px;
        }
        #game-over-message h3 { margin-top: 0; margin-bottom: 15px; font-size: 24px; color: #FFD700; }
        #game-over-message p { margin: 8px 0; font-size: 18px; }
        #piece-container {
            display: flex; justify-content: space-around; align-items: flex-start;
            min-height: 80px; padding: 10px; background-color: #A0522D;
            border-radius: 8px; box-shadow: inset 0 0 8px rgba(0,0,0,0.3);
        }
        .piece-slot { width: 30%; display: flex; justify-content: center; align-items: center; min-height: 60px; }
        .piece { display: grid; cursor: grab; border: 1px solid transparent; touch-action: none; }
        .piece.is-being-dragged { opacity: 0.3; cursor: grabbing; }
        .piece.hint-piece { opacity: 0.6; cursor: default !important; }
        .piece-cell {
            width: 18px; height: 18px; background-color: #CD853F;
            border: 1px solid #8B4513; box-shadow: inset 1px 1px 3px rgba(0,0,0,0.2);
        }
        .piece-cell.empty { background-color: transparent; border: none; box-shadow: none; }
        .piece-clone {
            position: absolute; z-index: 1000; opacity: 0.75;
            pointer-events: none; transform-origin: top left;
        }
        button {
            background-color: #D2691E; color: white; border: 2px solid #8B4513;
            padding: 12px 25px; font-size: 18px; border-radius: 8px; cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
            box-shadow: 0 4px #8B4513; margin: 10px 5px;
        }
        button:hover { background-color: #B85C1A; }
        button:active { transform: translateY(2px); box-shadow: 0 2px #8B4513; }
        h1, h2 { color: #FFF0E1; font-family: 'Roboto Slab', serif;}
        .music-controls { margin-top: 20px; padding-top: 15px; border-top: 1px solid #6B4226; }
        .music-controls h3 { margin-bottom: 10px; font-size: 18px; color: #FFF0E1; }
        .volume-control-container { display: flex; align-items: center; justify-content: center; margin-top: 5px; }
        #volume-slider { width: 180px; cursor: pointer; }

        .game-info-section {
            background-color: #8B4513; 
            color: #FFF0E1;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0,0,0,0.3), inset 0 0 10px rgba(50,20,0,0.5);
            margin-top: 30px;
            max-width: 90vw;
            width: 600px; 
            text-align: left;
            line-height: 1.6;
        }
        .game-info-section h2 {
            font-family: 'Roboto Slab', serif;
            color: #FFD700; 
            border-bottom: 1px solid #A0522D;
            padding-bottom: 10px;
            margin-top: 0;
        }
        .game-info-section h3 {
            font-family: 'Roboto Slab', serif;
            color: #FFD700;
            margin-top: 20px;
        }
        .game-info-section p, .game-info-section ol, .game-info-section ul {
            font-size: 1em;
            margin-bottom: 10px;
        }
        .game-info-section ol, .game-info-section ul {
            padding-left: 20px;
        }
        .game-info-section ul li { list-style: disc; margin-bottom: 5px;}
        .game-info-section ol li { list-style: decimal; margin-bottom: 5px;}

         @media (max-width: 640px) {
            .game-info-section { width: 90vw; }
            .top-nav-bar { flex-direction: column; align-items: flex-start; gap: 5px;}
            .top-nav-bar .nav-links { margin-left:0; margin-top: 5px; }
            .top-nav-bar .nav-links a { margin-left: 0; margin-right: 10px;}
            body { padding-top: 90px; }
        }
    </style>
</head>
<body>
    <nav class="top-nav-bar">
        <div class="logo"><a href="index.html">GameVerse</a></div>
        <div class="nav-links">
            <a href="index.html">Home</a>
            <!-- IMPORTANT: Create these pages (about.html, contact.html) with unique content -->
            <!-- <a href="about.html">About Us</a> -->
            <!-- <a href="contact.html">Contact Us</a> -->
            <a href="privacy_policy.html">Privacy Policy</a>
        </div>
    </nav>

    <audio id="menu-music" loop src="background music.mp3"></audio>
    <audio id="game-music" loop src="background music 2.mp3"></audio>
    <audio id="drag-sound" loop src="gear.mp3"></audio>
    <audio id="drop-sound" src="drop object.mp3"></audio>
    <audio id="line-clear-sound" src="line clear.mp3"></audio>

    <div class="game-container">
        <div id="combo-popup-message" class="combo-popup"></div>

        <div id="start-screen" class="screen active">
            <h1>Wood Block Puzzle</h1>
            <button id="start-game-btn">Start Game</button>
        </div>

        <div id="difficulty-screen" class="screen">
            <h2>Select Difficulty</h2>
            <button class="difficulty-btn" data-difficulty="easy">Easy</button>
            <button class="difficulty-btn" data-difficulty="medium">Medium</button>
            <button class="difficulty-btn" data-difficulty="hard">Hard</button>

            <div class="music-controls">
                <h3>Music Volume</h3>
                <div class="volume-control-container">
                    <input type="range" id="volume-slider" min="0" max="1" step="0.01" value="0.5">
                </div>
            </div>
        </div>

        <div id="game-screen" class="screen">
            <div id="game-header">
                 <button id="back-to-difficulty-btn">< Back</button>
                 <div id="score-area">Score: <span id="score">0</span></div>
            </div>
            <div id="game-board"></div>
            <div id="piece-container">
                <div class="piece-slot" id="slot-0"></div>
                <div class="piece-slot" id="slot-1"></div>
                <div class="piece-slot" id="slot-2"></div>
            </div>
            <div id="game-over-message" style="display:none;">
                <!-- Content dynamically set by gameOver() -->
            </div>
        </div>
    </div>

    <section class="game-info-section">
        <h2>About Wood Block Puzzle</h2>
        <p>Welcome to the classic Wood Block Puzzle on GameVerse! This isn't just any puzzle; it's a mental workout wrapped in a charming wooden aesthetic. The game is designed to test your strategic foresight and spatial awareness. Your mission, should you choose to accept it, is to deftly arrange an assortment of wooden blocks onto a 10x10 grid. The real magic happens when you complete a full line – poof! It vanishes, clearing space and earning you points. While the basics are a breeze to pick up, achieving true mastery requires practice and a keen eye for patterns. This version of the game offers varying difficulty levels to suit everyone from the casual player to the seasoned puzzle enthusiast.</p>

        <h3>How to Play: Step-by-Step</h3>
        <ol>
            <li><strong>Starting Up:</strong> Once you select your difficulty and start the game, you'll see a 10x10 empty grid and three wooden block pieces at the bottom.</li>
            <li><strong>Placing Blocks:</strong> Simply tap (or click and drag) one of the three pieces and move it onto the game board. Release to place it. The piece must fit entirely within the empty cells.</li>
            <li><strong>Clearing Lines:</strong> Your primary goal is to fill either a horizontal row or a vertical column completely with blocks. Once a line is full, it will clear, freeing up space and adding to your score.</li>
            <li><strong>New Pieces:</strong> After you place a piece, if its slot was the first or second, the remaining pieces will shift, and a new "hint" piece will appear in the third slot, giving you a glimpse of what's coming. If all three pieces are used, three new pieces will be generated.</li>
            <li><strong>Game Over Condition:</strong> The game concludes if you reach a point where none of the three available block pieces can be legally placed anywhere on the board. So, think carefully before each move!</li>
            <li><strong>Scoring:</strong> You get points for each block cell placed. Clearing lines awards bonus points, and clearing multiple lines at once (a combo!) results in an even bigger score boost. The difficulty level also influences your final score multiplier.</li>
        </ol>

        <h3>Key Features of Our Wood Block Puzzle</h3>
        <ul>
            <li><strong>Multiple Difficulty Levels:</strong> Choose from Easy, Medium, or Hard to match your skill. Harder levels might introduce more complex pieces or affect scoring.</li>
            <li><strong>Intuitive Drag and Drop:</strong> Smooth and responsive controls make placing blocks a joy.</li>
            <li><strong>Engaging Sound Effects:</strong> Satisfying sounds for placing blocks and clearing lines. Music volume is adjustable.</li>
            <li><strong>No Time Limit:</strong> Play at your own pace. This is a game of strategy, not speed.</li>
            <li><strong>High Score Tracking:</strong> Challenge yourself to beat your personal best (stored locally in your browser for each difficulty).</li>
            <li><strong>Combo System:</strong> Get rewarded with extra points and encouraging messages for clearing multiple lines in a single move.</li>
            <li><strong>Clean, Wooden Aesthetic:</strong> Enjoy a visually pleasing and relaxing game environment with a cool line-clearing effect.</li>
        </ul>

        <h3>Tips and Strategies for a High Score</h3>
        <ul>
            <li><strong>Think Several Moves Ahead:</strong> Don't just focus on the immediate piece. Look at all three available pieces and the hint piece to plan your placements.</li>
            <li><strong>Corner Management:</strong> Corners can be tricky. Try to keep them relatively open or fill them strategically. Avoid trapping yourself.</li>
            <li><strong>Create Space for Large Pieces:</strong> The 3x3 square or long I-shapes need significant space. Always try to maintain areas where these larger pieces can fit.</li>
            <li><strong>Don't Neglect Small Gaps:</strong> While you want space for big pieces, don't let small, awkward gaps accumulate. Use smaller pieces to fill these when possible.</li>
            <li><strong>Prioritize Multiple Line Clears:</strong> Setting up for a double or triple line clear is often more valuable than clearing a single line immediately. This also triggers better performance messages!</li>
            <li><strong>The "Waiting Game":</strong> Sometimes, it's better to make a slightly suboptimal move if it means keeping your options open for a piece you desperately need or to clear a critical line.</li>
            <li><strong>Learn Piece Patterns:</strong> Familiarize yourself with all the possible block shapes. Knowing what might come next helps in strategic board management.</li>
        </ul>
         <p>Dive into the relaxing yet stimulating world of Wood Block Puzzle. Sharpen your mind, challenge your friends (by comparing high scores!), and enjoy countless hours of classic puzzle fun, right here on GameVerse!</p>
    </section>

    <footer class="site-footer">
        <p>© <span id="currentYear"></span> GameVerse by Kanhaiya Mishra. All Rights Reserved.</p>
        <p><a href="index.html">Home</a> | <a href="privacy_policy.html">Privacy Policy</a></p>
    </footer>

    <script>
        const GRID_SIZE = 10;
        const gameBoardElement = document.getElementById('game-board');
        const scoreElement = document.getElementById('score');
        const pieceSlots = [
            document.getElementById('slot-0'),
            document.getElementById('slot-1'),
            document.getElementById('slot-2')
        ];

        const startScreen = document.getElementById('start-screen');
        const difficultyScreen = document.getElementById('difficulty-screen');
        const gameScreen = document.getElementById('game-screen');
        const gameOverMessageDiv = document.getElementById('game-over-message');
        const comboPopupMessageElement = document.getElementById('combo-popup-message');
        const backToDifficultyBtn = document.getElementById('back-to-difficulty-btn');


        const menuMusic = document.getElementById('menu-music');
        const gameMusic = document.getElementById('game-music');
        const dragSound = document.getElementById('drag-sound');
        const dropSound = document.getElementById('drop-sound');
        const lineClearSound = document.getElementById('line-clear-sound');
        const volumeSlider = document.getElementById('volume-slider');

        let board = [];
        let score = 0;
        let currentPieces = [null, null, null];
        let difficulty = 'medium';
        let difficultyMultipliers = { easy: 0.8, medium: 1, hard: 1.3 };
        const HIGH_SCORE_KEY = 'woodBlockPuzzleHighScore'; // Base key, difficulty will be appended

        const PIECES = {
            SINGLE: { shape: [[1]], id: 'SINGLE' }, DOMINO1X2_H: { shape: [[1,1]], id: 'DOMINO1X2_H' },
            DOMINO1X2_V: { shape: [[1],[1]], id: 'DOMINO1X2_V' }, SQUARE2X2: { shape: [[1,1],[1,1]], id: 'SQUARE2X2' },
            CORNER_A: { shape: [[1,1],[1,0]], id: 'CORNER_A'}, CORNER_B: { shape: [[1,1],[0,1]], id: 'CORNER_B'},
            I3_H: { shape: [[1,1,1]], id: 'I3_H' }, I3_V: { shape: [[1],[1],[1]], id: 'I3_V' },
            L_SHAPE_A: { shape: [[1,0],[1,0],[1,1]], id: 'L_SHAPE_A' }, L_SHAPE_B: { shape: [[1,1],[1,0],[1,0]], id: 'L_SHAPE_B' },
            T_SHAPE: { shape: [[1,1,1],[0,1,0]], id: 'T_SHAPE' }, S_SHAPE: { shape: [[0,1,1],[1,1,0]], id: 'S_SHAPE' },
            Z_SHAPE: { shape: [[1,1,0],[0,1,1]], id: 'Z_SHAPE' }, U_SHAPE_3X2: { shape: [[1,0,1],[1,1,1]], id: 'U_SHAPE_3X2'},
            C_SHAPE_3X2_A: { shape: [[1,1],[1,0],[1,1]], id: 'C_SHAPE_3X2_A' }, C_SHAPE_3X2_B: { shape: [[1,1],[0,1],[1,1]], id: 'C_SHAPE_3X2_B' },
            SMALL_HAT_V: { shape: [[1,0],[1,1],[1,0]], id: 'SMALL_HAT_V' }, I4_H: { shape: [[1,1,1,1]], id: 'I4_H' },
            I4_V: { shape: [[1],[1],[1],[1]], id: 'I4_V' }, L_LARGE_A: { shape: [[1,0],[1,0],[1,0],[1,1]], id: 'L_LARGE_A' },
            L_LARGE_B: { shape: [[0,1],[0,1],[0,1],[1,1]], id: 'L_LARGE_B' }, SQUARE3X3: { shape: [[1,1,1],[1,1,1],[1,1,1]], id: 'SQUARE3X3'},
            HOLLOW_SQUARE_3X3: { shape: [[1,1,1],[1,0,1],[1,1,1]], id: 'HOLLOW_SQUARE_3X3'},
            CROSS_5_HIGH: {shape: [[0,1,0],[0,1,0],[1,1,1],[0,1,0],[0,1,0]], id: 'CROSS_5_HIGH'},
            CROSS_3H_5W: {shape: [[0,0,1,0,0],[1,1,1,1,1],[0,0,1,0,0]], id: 'CROSS_3H_5W'},
            AWKWARD_ANGLE_A: { shape: [[1,1,0],[0,1,1],[0,0,1]], id: 'AWKWARD_ANGLE_A'},
            AWKWARD_ANGLE_B: { shape: [[0,1,1],[1,1,0],[1,0,0]], id: 'AWKWARD_ANGLE_B'},
            I5_H: { shape: [[1,1,1,1,1]], id: 'I5_H' }, I5_V: { shape: [[1],[1],[1],[1],[1]], id: 'I5_V' },
        };

        const NEW_EASY_PIECE_KEYS_POOL = [
            'SINGLE', 'SINGLE', 'SINGLE', 'SINGLE', 'SINGLE', 'SINGLE', 'SINGLE', 'SINGLE', 'SINGLE', 'SINGLE',
            'DOMINO1X2_H', 'DOMINO1X2_H', 'DOMINO1X2_H', 'DOMINO1X2_H', 'DOMINO1X2_H',
            'DOMINO1X2_V', 'DOMINO1X2_V', 'DOMINO1X2_V', 'DOMINO1X2_V', 'DOMINO1X2_V',
            'SQUARE2X2', 'SQUARE2X2', 'SQUARE2X2', 'SQUARE2X2',
            'CORNER_A', 'CORNER_A', 'CORNER_B', 'CORNER_B', 'I3_H', 'I3_V'
        ];
        const NEW_MEDIUM_PIECE_KEYS_POOL = [
            'SINGLE', 'DOMINO1X2_H', 'DOMINO1X2_V', 'SQUARE2X2', 'SQUARE2X2',
            'CORNER_A', 'CORNER_A', 'CORNER_B', 'CORNER_B', 'I3_H', 'I3_H', 'I3_V', 'I3_V',
            'L_SHAPE_A', 'L_SHAPE_A', 'L_SHAPE_B', 'L_SHAPE_B', 'T_SHAPE', 'T_SHAPE', 'T_SHAPE',
            'S_SHAPE', 'S_SHAPE', 'Z_SHAPE', 'Z_SHAPE', 'U_SHAPE_3X2',
            'C_SHAPE_3X2_A', 'C_SHAPE_3X2_B', 'SMALL_HAT_V', 'I4_H', 'I4_V'
        ];
        const NEW_HARD_PIECE_KEYS_POOL = [
            'I3_H', 'I3_V', 'L_SHAPE_A', 'L_SHAPE_B', 'T_SHAPE', 'T_SHAPE',
            'S_SHAPE', 'S_SHAPE', 'Z_SHAPE', 'Z_SHAPE', 'U_SHAPE_3X2', 'U_SHAPE_3X2',
            'C_SHAPE_3X2_A', 'C_SHAPE_3X2_B', 'SMALL_HAT_V', 'SMALL_HAT_V',
            'I4_H', 'I4_H', 'I4_V', 'I4_V', 'L_LARGE_A', 'L_LARGE_A',
            'L_LARGE_B', 'L_LARGE_B', 'SQUARE3X3', 'HOLLOW_SQUARE_3X3',
            'CROSS_5_HIGH', 'CROSS_3H_5W', 'AWKWARD_ANGLE_A', 'AWKWARD_ANGLE_B', 'I5_H', 'I5_V'
        ];

        let easyPieceBag = [];
        let mediumPieceBag = [];
        let hardPieceBag = [];

        let isDragging = false;
        let draggedPieceData = null;
        let draggedPieceCloneElement = null;
        let originalPieceElement = null;
        let dragOffsetX = 0;
        let dragOffsetY = 0;
        let mainCellSize = 30; 
        const PIECE_PREVIEW_CELL_SIZE = 18;
        const LINE_CLEAR_ANIMATION_DURATION = 400; // Matched to CSS animation: 0.4s
        let comboPopupTimeout = null;


        function playSound(soundElement, loop = false) {
            if (soundElement) {
                soundElement.loop = loop;
                soundElement.currentTime = 0;
                soundElement.play().catch(e => console.warn("Sound play failed:", e));
            }
        }

        function stopSound(soundElement) {
            if(soundElement){
                soundElement.pause();
                soundElement.currentTime = 0;
            }
        }

        function showComboPopup(message) {
            if (comboPopupTimeout) clearTimeout(comboPopupTimeout);

            comboPopupMessageElement.textContent = message;
            comboPopupMessageElement.classList.remove('hide');
            comboPopupMessageElement.classList.add('show');

            comboPopupTimeout = setTimeout(() => {
                comboPopupMessageElement.classList.remove('show');
                comboPopupMessageElement.classList.add('hide');
            }, 1500); // Message display duration
        }


        function initGame() {
            document.getElementById('start-game-btn').addEventListener('click', () => {
                 showDifficultyScreen();
                 if (parseFloat(volumeSlider.value) > 0 && menuMusic.paused) {
                     menuMusic.play().catch(e => console.warn("Menu music play failed on start button:", e));
                 }
            });
            document.querySelectorAll('.difficulty-btn').forEach(btn => {
                btn.addEventListener('click', (e) => selectDifficulty(e.target.dataset.difficulty));
            });

            backToDifficultyBtn.addEventListener('click', () => {
                gameMusic.pause();
                if (parseFloat(volumeSlider.value) > 0 && menuMusic.paused) {
                    menuMusic.play().catch(e => console.warn("Menu music play failed on back button:", e));
                }
                showDifficultyScreen();
            });

            createBoardCells();
            const initialVolume = parseFloat(volumeSlider.value);
            menuMusic.volume = initialVolume;
            gameMusic.volume = initialVolume;
            dragSound.volume = initialVolume;
            dropSound.volume = initialVolume;
            lineClearSound.volume = initialVolume;


            if (initialVolume == 0) {
                menuMusic.pause();
                gameMusic.pause();
            }
            volumeSlider.addEventListener('input', (e) => {
                const newVolume = parseFloat(e.target.value);
                menuMusic.volume = newVolume;
                gameMusic.volume = newVolume;
                dragSound.volume = newVolume;
                dropSound.volume = newVolume;
                lineClearSound.volume = newVolume;

                if (newVolume > 0) {
                    if (gameScreen.classList.contains('active') && gameMusic.paused) {
                        gameMusic.play().catch(error => console.warn("Game music play failed on slider change:", error));
                    } else if ((startScreen.classList.contains('active') || difficultyScreen.classList.contains('active')) && menuMusic.paused) {
                         menuMusic.play().catch(error => console.warn("Menu music play failed on slider change:", error));
                    }
                } else {
                    menuMusic.pause();
                    gameMusic.pause();
                }
            });
            document.getElementById('currentYear').textContent = new Date().getFullYear();
        }

        function showStartScreen() {
            startScreen.classList.add('active');
            difficultyScreen.classList.remove('active');
            gameScreen.classList.remove('active');
            gameOverMessageDiv.style.display = 'none';
            if(!gameMusic.paused) gameMusic.pause();
            if (parseFloat(volumeSlider.value) > 0 && menuMusic.paused) {
                menuMusic.play().catch(e => console.warn("Menu music play on showStartScreen failed:", e));
            }
        }

        function showDifficultyScreen() {
            startScreen.classList.remove('active');
            difficultyScreen.classList.add('active');
            gameScreen.classList.remove('active');
            gameOverMessageDiv.style.display = 'none';
            if(!gameMusic.paused) gameMusic.pause();
            if (parseFloat(volumeSlider.value) > 0 && menuMusic.paused) {
                menuMusic.play().catch(e => console.warn("Menu music play on showDifficultyScreen failed:", e));
            }
        }

        function selectDifficulty(selectedDifficulty) {
            difficulty = selectedDifficulty;
            easyPieceBag = []; // Reset bags on difficulty change
            mediumPieceBag = [];
            hardPieceBag = [];
            if(!menuMusic.paused) menuMusic.pause();
            if (parseFloat(volumeSlider.value) > 0 && gameMusic.paused) {
                 const playPromise = gameMusic.play();
                 if (playPromise !== undefined) {
                    playPromise.catch(error => console.warn("Game music play on game start failed:", error));
                 }
            }
            startGame();
        }

        function startGame() {
            showGameScreen();
            board = Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(0));
            score = 0;
            updateScoreDisplay();
            renderBoard(); // Render board once before calculating mainCellSize
            const firstGridCell = gameBoardElement.querySelector('.grid-cell');
            if (firstGridCell) {
                 mainCellSize = firstGridCell.offsetWidth;
            } else {
                mainCellSize = 30; // Fallback, though board should always have cells
            }
            if(isNaN(mainCellSize) || mainCellSize <= 0) mainCellSize = 30; // Ensure valid size

            initialFillAllSlots();
            gameOverMessageDiv.style.display = 'none';
        }

        function showGameScreen() {
            startScreen.classList.remove('active');
            difficultyScreen.classList.remove('active');
            gameScreen.classList.add('active');
            gameOverMessageDiv.style.display = 'none';
        }

        function createBoardCells() {
            gameBoardElement.innerHTML = '';
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    const cell = document.createElement('div');
                    cell.classList.add('grid-cell');
                    cell.dataset.r = r;
                    cell.dataset.c = c;
                    gameBoardElement.appendChild(cell);
                }
            }
        }
        function renderBoard() {
             for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    const cellElement = gameBoardElement.children[r * GRID_SIZE + c];
                    if (board[r][c] === 1) {
                        cellElement.classList.add('filled');
                    } else {
                        cellElement.classList.remove('filled');
                    }
                    // Remove line-clearing class after animation is done (handled by 'forwards' in CSS)
                    // or if re-rendering before animation finishes to prevent stale state.
                    cellElement.classList.remove('line-clearing');
                }
            }
        }

        function getPieceKeyFromBag(difficultyLevel) {
            let targetBag;
            let sourcePool;
            let pieceBagRef; // To correctly reference the global bag variable name for refilling

            if (difficultyLevel === 'easy') {
                targetBag = easyPieceBag; sourcePool = NEW_EASY_PIECE_KEYS_POOL; pieceBagRef = 'easyPieceBag';
            } else if (difficultyLevel === 'medium') {
                targetBag = mediumPieceBag; sourcePool = NEW_MEDIUM_PIECE_KEYS_POOL; pieceBagRef = 'mediumPieceBag';
            } else if (difficultyLevel === 'hard') {
                targetBag = hardPieceBag; sourcePool = NEW_HARD_PIECE_KEYS_POOL; pieceBagRef = 'hardPieceBag';
            } else { // Default to medium if difficulty is somehow undefined
                targetBag = mediumPieceBag; sourcePool = NEW_MEDIUM_PIECE_KEYS_POOL; pieceBagRef = 'mediumPieceBag';
            }

            if (targetBag.length === 0) {
                if (!sourcePool || sourcePool.length === 0) return 'SINGLE'; // Fallback if pool is empty
                
                // Refill the correct global bag
                if (pieceBagRef === 'easyPieceBag') easyPieceBag.push(...[...sourcePool]);
                else if (pieceBagRef === 'mediumPieceBag') mediumPieceBag.push(...[...sourcePool]);
                else if (pieceBagRef === 'hardPieceBag') hardPieceBag.push(...[...sourcePool]);
                
                // Update targetBag to point to the now filled global bag
                if (pieceBagRef === 'easyPieceBag') targetBag = easyPieceBag;
                else if (pieceBagRef === 'mediumPieceBag') targetBag = mediumPieceBag;
                else if (pieceBagRef === 'hardPieceBag') targetBag = hardPieceBag;
            }
            if (targetBag.length === 0) return 'SINGLE'; // Should ideally not be reached if sourcePool is valid

            const randomIndex = Math.floor(Math.random() * targetBag.length);
            return targetBag.splice(randomIndex, 1)[0];
        }

        function generateRandomPieceData(targetSlotIndex) {
            const randomPieceKey = getPieceKeyFromBag(difficulty);
            if (!PIECES[randomPieceKey]) {
                console.error("Invalid piece key generated:", randomPieceKey, "Falling back to SINGLE.");
                return { piece: PIECES['SINGLE'], shape: PIECES['SINGLE'].shape, slotIndex: targetSlotIndex };
            }
            return {
                piece: PIECES[randomPieceKey],
                shape: PIECES[randomPieceKey].shape,
                slotIndex: targetSlotIndex
            };
        }

        function initialFillAllSlots() {
            for (let i = 0; i < 3; i++) {
                currentPieces[i] = generateRandomPieceData(i);
                renderPieceInSlot(currentPieces[i], pieceSlots[i]);
            }
            checkGameOver();
        }

        function renderPieceInSlot(pieceData, slotElement) {
            slotElement.innerHTML = '';
            if (!pieceData) return;
            const pieceElement = document.createElement('div');
            pieceElement.classList.add('piece');
            const shape = pieceData.shape;
            pieceElement.style.gridTemplateRows = `repeat(${shape.length}, 1fr)`;
            pieceElement.style.gridTemplateColumns = `repeat(${shape[0].length}, 1fr)`;

            for (let r_shape = 0; r_shape < shape.length; r_shape++) {
                for (let c_shape = 0; c_shape < shape[0].length; c_shape++) {
                    const cell = document.createElement('div');
                    cell.classList.add('piece-cell');
                    if (shape[r_shape][c_shape] === 0) {
                        cell.classList.add('empty');
                    }
                    pieceElement.appendChild(cell);
                }
            }

            if (pieceData.slotIndex === 2) { // Hint piece slot (index 2)
                pieceElement.classList.add('hint-piece');
                // Hint pieces are not draggable
            } else { // Playable piece slots (index 0 and 1)
                pieceElement.addEventListener('pointerdown', (e) => onPiecePointerDown(e, pieceData, pieceElement));
            }
            slotElement.appendChild(pieceElement);
        }

        function shiftAndRefillPieces(usedSlotIndex) {
            if (usedSlotIndex === 0) { // Piece from slot 0 used
                currentPieces[0] = currentPieces[1]; // Slot 1 piece moves to slot 0
                if (currentPieces[0]) currentPieces[0].slotIndex = 0;

                currentPieces[1] = currentPieces[2]; // Hint piece (slot 2) moves to slot 1
                if (currentPieces[1]) currentPieces[1].slotIndex = 1;

            } else if (usedSlotIndex === 1) { // Piece from slot 1 used
                // currentPieces[0] remains as is
                currentPieces[1] = currentPieces[2]; // Hint piece (slot 2) moves to slot 1
                if (currentPieces[1]) currentPieces[1].slotIndex = 1;
            }
            // A new hint piece is always generated for slot 2
            currentPieces[2] = generateRandomPieceData(2);

            // Re-render all slots
            renderPieceInSlot(currentPieces[0], pieceSlots[0]);
            renderPieceInSlot(currentPieces[1], pieceSlots[1]);
            renderPieceInSlot(currentPieces[2], pieceSlots[2]); // Render the new hint piece

            checkGameOver(); // Check if game is over with the new set of pieces
        }


        function onPiecePointerDown(event, pieceData, pieceElement) {
            if (isDragging || event.button !== 0 || pieceData.slotIndex === 2) return; // Ensure hint piece is not draggable
            event.preventDefault();

            playSound(dragSound, true);

            isDragging = true;
            draggedPieceData = pieceData;
            originalPieceElement = pieceElement;
            const rect = pieceElement.getBoundingClientRect();
            dragOffsetX = event.clientX - rect.left;
            dragOffsetY = event.clientY - rect.top;
            
            const scaleFactor = mainCellSize / PIECE_PREVIEW_CELL_SIZE;

            draggedPieceCloneElement = pieceElement.cloneNode(true);
            draggedPieceCloneElement.classList.add('piece-clone');
            // Set overall size of the clone based on scaled dimensions
            draggedPieceCloneElement.style.width = `${pieceElement.offsetWidth * scaleFactor}px`;
            draggedPieceCloneElement.style.height = `${pieceElement.offsetHeight * scaleFactor}px`;

            // Scale individual cells within the clone
            const cloneCells = draggedPieceCloneElement.querySelectorAll('.piece-cell');
            cloneCells.forEach(cell => {
                 if(!cell.classList.contains('empty')) { // Only scale actual block cells
                    cell.style.width = `${mainCellSize}px`;
                    cell.style.height = `${mainCellSize}px`;
                 }
            });
            
            document.body.appendChild(draggedPieceCloneElement);
            document.body.classList.add('dragging-active');
            
            draggedPieceCloneElement.style.left = `${event.clientX - (dragOffsetX * scaleFactor)}px`;
            draggedPieceCloneElement.style.top = `${event.clientY - (dragOffsetY * scaleFactor)}px`;
            
            originalPieceElement.classList.add('is-being-dragged'); // Make original transparent
            
            document.addEventListener('pointermove', onDocumentPointerMove);
            document.addEventListener('pointerup', onDocumentPointerUp);
            document.addEventListener('pointercancel', onDocumentPointerUp);
        }

        function onDocumentPointerMove(event) {
            if (!isDragging || !draggedPieceCloneElement) return;
            event.preventDefault();
            const scaleFactor = mainCellSize / PIECE_PREVIEW_CELL_SIZE;
            const currentX = event.clientX - (dragOffsetX * scaleFactor);
            const currentY = event.clientY - (dragOffsetY * scaleFactor);
            draggedPieceCloneElement.style.left = `${currentX}px`;
            draggedPieceCloneElement.style.top = `${currentY}px`;

            const gameBoardRect = gameBoardElement.getBoundingClientRect();
            
            // Use the clone's current position for preview calculation
            const cloneRect = draggedPieceCloneElement.getBoundingClientRect();
            let boardRelativeX = cloneRect.left - gameBoardRect.left;
            let boardRelativeY = cloneRect.top - gameBoardRect.top;

            // Potential drop row and col based on the center of the first block of the piece
            let potentialDropR = Math.floor((boardRelativeY + mainCellSize / 2) / mainCellSize);
            let potentialDropC = Math.floor((boardRelativeX + mainCellSize / 2) / mainCellSize);

            clearPreview();
            if (draggedPieceData && canPlacePiece(draggedPieceData.shape, potentialDropR, potentialDropC)) {
                drawPreview(draggedPieceData.shape, potentialDropR, potentialDropC);
            }
        }

        async function onDocumentPointerUp(event) {
            if (!isDragging) return;

            stopSound(dragSound);

            document.removeEventListener('pointermove', onDocumentPointerMove);
            document.removeEventListener('pointerup', onDocumentPointerUp);
            document.removeEventListener('pointercancel', onDocumentPointerUp);
            document.body.classList.remove('dragging-active');

            let piecePlacedSuccessfully = false;

            if (draggedPieceCloneElement && draggedPieceData) {
                const gameBoardRect = gameBoardElement.getBoundingClientRect();
                
                const cloneRect = draggedPieceCloneElement.getBoundingClientRect();
                let boardRelativeX = cloneRect.left - gameBoardRect.left;
                let boardRelativeY = cloneRect.top - gameBoardRect.top;

                let dropR = Math.floor((boardRelativeY + mainCellSize / 2) / mainCellSize);
                let dropC = Math.floor((boardRelativeX + mainCellSize / 2) / mainCellSize);
                
                if (canPlacePiece(draggedPieceData.shape, dropR, dropC)) {
                    piecePlacedSuccessfully = true;
                    playSound(dropSound);
                    placePiece(draggedPieceData.shape, dropR, dropC);
                    addScore(draggedPieceData.shape.flat().reduce((sum, val) => sum + val, 0) * 5);
                    
                    const usedSlotOriginalIndex = draggedPieceData.slotIndex;
                    currentPieces[usedSlotOriginalIndex] = null; 
                    
                    const linesClearedInfo = await clearLines(); 
                    renderBoard(); 

                    // Updated performance messages based on lines cleared
                    if (linesClearedInfo.totalLines > 0) {
                        if (linesClearedInfo.totalLines >= 4) { // For 4 or more lines
                            showComboPopup("Excellent!");
                        } else if (linesClearedInfo.totalLines === 3) {
                            showComboPopup("Very Good!");
                        } else if (linesClearedInfo.totalLines === 2) {
                            showComboPopup("Good!");
                        } else if (linesClearedInfo.totalLines === 1) {
                             showComboPopup("Great!"); // Kept "Great!" for single line as per previous
                        }
                    }
                    shiftAndRefillPieces(usedSlotOriginalIndex);
                }
            }

            if (draggedPieceCloneElement) {
                draggedPieceCloneElement.remove();
                draggedPieceCloneElement = null;
            }
            if (originalPieceElement) {
                originalPieceElement.classList.remove('is-being-dragged');
                if (!piecePlacedSuccessfully && originalPieceElement.parentElement) { 
                    // If not placed and still in DOM, make it visible again
                    originalPieceElement.style.opacity = '1'; 
                } else if (!piecePlacedSuccessfully && !originalPieceElement.parentElement) {
                    // If it was removed from DOM (e.g. by re-render), re-render the slot
                    if(draggedPieceData) renderPieceInSlot(draggedPieceData, pieceSlots[draggedPieceData.slotIndex]);
                }
            }
            clearPreview();

            isDragging = false;
            draggedPieceData = null;
            originalPieceElement = null;
            
            if (piecePlacedSuccessfully) checkGameOver();
        }
        function clearPreview() {
            document.querySelectorAll('.grid-cell.preview').forEach(cell => cell.classList.remove('preview'));
        }
        function drawPreview(shape, startR, startC) {
            for (let rOffset = 0; rOffset < shape.length; rOffset++) {
                for (let cOffset = 0; cOffset < shape[0].length; cOffset++) {
                    if (shape[rOffset][cOffset] === 1) {
                        const boardR = startR + rOffset;
                        const boardC = startC + cOffset;
                        if (boardR >= 0 && boardR < GRID_SIZE && boardC >= 0 && boardC < GRID_SIZE) {
                           const cellEl = gameBoardElement.children[boardR * GRID_SIZE + boardC];
                           if (cellEl && !cellEl.classList.contains('filled')) {
                                cellEl.classList.add('preview');
                           }
                        }
                    }
                }
            }
        }
        function canPlacePiece(shape, startR, startC) {
            for (let rOffset = 0; rOffset < shape.length; rOffset++) {
                for (let cOffset = 0; cOffset < shape[0].length; cOffset++) {
                    if (shape[rOffset][cOffset] === 1) {
                        const boardR = startR + rOffset;
                        const boardC = startC + cOffset;
                        if (boardR >= GRID_SIZE || boardC >= GRID_SIZE || boardR < 0 || boardC < 0 || board[boardR][boardC] === 1) {
                            return false;
                        }
                    }
                }
            }
            return true;
        }
        function placePiece(shape, startR, startC) {
            for (let rOffset = 0; rOffset < shape.length; rOffset++) {
                for (let cOffset = 0; cOffset < shape[0].length; cOffset++) {
                    if (shape[rOffset][cOffset] === 1) {
                        board[startR + rOffset][startC + cOffset] = 1;
                    }
                }
            }
        }

        async function clearLines() {
            let rowsToClear = [];
            let colsToClear = [];
            let cellsToAnimateElements = [];

            for (let r = 0; r < GRID_SIZE; r++) {
                if (board[r].every(cell => cell === 1)) {
                    rowsToClear.push(r);
                    for (let c = 0; c < GRID_SIZE; c++) {
                        cellsToAnimateElements.push(gameBoardElement.children[r * GRID_SIZE + c]);
                    }
                }
            }

            for (let c = 0; c < GRID_SIZE; c++) {
                let colFull = true;
                for (let r = 0; r < GRID_SIZE; r++) {
                    if (board[r][c] === 0) {
                        colFull = false;
                        break;
                    }
                }
                if (colFull) {
                    colsToClear.push(c);
                    for (let r = 0; r < GRID_SIZE; r++) {
                        const cellElement = gameBoardElement.children[r * GRID_SIZE + c];
                        if (!cellsToAnimateElements.includes(cellElement)) {
                            cellsToAnimateElements.push(cellElement);
                        }
                    }
                }
            }

            const totalLinesCleared = rowsToClear.length + colsToClear.length;

            if (cellsToAnimateElements.length > 0) {
                playSound(lineClearSound);
                cellsToAnimateElements.forEach(cellEl => cellEl.classList.add('line-clearing'));

                await new Promise(resolve => setTimeout(resolve, LINE_CLEAR_ANIMATION_DURATION));

                rowsToClear.forEach(r => {
                    for (let c = 0; c < GRID_SIZE; c++) board[r][c] = 0;
                });
                colsToClear.forEach(c => {
                    for (let r = 0; r < GRID_SIZE; r++) board[r][c] = 0;
                });
                
                // Scoring based on total lines cleared in this single event
                if (totalLinesCleared > 0) {
                    let lineScore = 0;
                    // More granular scoring for multiple lines
                    if (totalLinesCleared === 1) lineScore = 100;
                    else if (totalLinesCleared === 2) lineScore = 300; // e.g., 100 + 200
                    else if (totalLinesCleared === 3) lineScore = 600; // e.g., 100 + 200 + 300
                    else if (totalLinesCleared >= 4) lineScore = 1000 + (totalLinesCleared - 4) * 500;
                    addScore(lineScore);
                }
            }
            return { totalLines: totalLinesCleared };
        }


        function addScore(points) {
            score += Math.round(points * difficultyMultipliers[difficulty]);
            updateScoreDisplay();
        }
        function updateScoreDisplay() {
             scoreElement.textContent = score;
        }
        function checkGameOver() {
            let canPlaceAnyPlayable = false;
            // Only check the two playable slots (0 and 1)
            for (let pieceIdx = 0; pieceIdx < 2; pieceIdx++) {
                if (currentPieces[pieceIdx]) { // If there's a piece in the slot
                    const pieceShape = currentPieces[pieceIdx].shape;
                    for (let r = 0; r < GRID_SIZE; r++) {
                        for (let c = 0; c < GRID_SIZE; c++) {
                            if (canPlacePiece(pieceShape, r, c)) {
                                canPlaceAnyPlayable = true;
                                break; 
                            }
                        }
                        if (canPlaceAnyPlayable) break; 
                    }
                }
                if (canPlaceAnyPlayable) break; 
            }
            
            const hasPlayablePiece = currentPieces[0] !== null || currentPieces[1] !== null;

            if (hasPlayablePiece && !canPlaceAnyPlayable) {
                 gameOver();
            }
        }


        function gameOver() {
            // Use difficulty-specific high score key
            const currentHighScoreKey = HIGH_SCORE_KEY + `_${difficulty}`;
            let highScore = localStorage.getItem(currentHighScoreKey);
            if (highScore === null) {
                highScore = 0;
            } else {
                highScore = parseInt(highScore);
            }

            if (score > highScore) {
                highScore = score;
                localStorage.setItem(currentHighScoreKey, highScore);
            }

            gameOverMessageDiv.innerHTML = `
                <h3>Game Over!</h3>
                <p>Difficulty: ${difficulty.charAt(0).toUpperCase() + difficulty.slice(1)}</p>
                <p>Your Score: ${score}</p>
                <p>High Score (${difficulty}): ${highScore}</p>
                <button id="restart-game-over-btn">Play Again</button>
            `;
            gameOverMessageDiv.style.display = 'block';

            const restartGameOverBtn = document.getElementById('restart-game-over-btn');
            if(restartGameOverBtn){
                restartGameOverBtn.addEventListener('click', () => {
                    gameOverMessageDiv.style.display = 'none';
                    gameMusic.pause();
                    if (parseFloat(volumeSlider.value) > 0 && menuMusic.paused) {
                        menuMusic.play().catch(e => console.warn("Menu music play failed on restart (game over):", e));
                    }
                    showDifficultyScreen(); // Return to difficulty selection for a new game
                });
            }

            isDragging = false;
            if (draggedPieceCloneElement) draggedPieceCloneElement.remove();
            document.body.classList.remove('dragging-active');
        }

        initGame();
        showStartScreen();
    </script>
</body>
</html>
